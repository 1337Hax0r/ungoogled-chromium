description: Fix building with safe_browsing=0 in gyp flags

--- a/chrome/browser/extensions/blacklist.cc
+++ b/chrome/browser/extensions/blacklist.cc
@@ -272,18 +272,9 @@ void Blacklist::ReturnBlacklistStateMap(
 void Blacklist::RequestExtensionsBlacklistState(
     const std::set<std::string>& ids, const base::Callback<void()>& callback) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  if (!state_fetcher_)
-    state_fetcher_.reset(new BlacklistStateFetcher());
 
   state_requests_.push_back(
       make_pair(std::vector<std::string>(ids.begin(), ids.end()), callback));
-  for (std::set<std::string>::const_iterator it = ids.begin();
-       it != ids.end();
-       ++it) {
-    state_fetcher_->Request(
-        *it,
-        base::Bind(&Blacklist::OnBlacklistStateReceived, AsWeakPtr(), *it));
-  }
 }
 
 void Blacklist::OnBlacklistStateReceived(const std::string& id,
@@ -318,11 +309,10 @@ void Blacklist::OnBlacklistStateReceived(const std::string& id,
 
 void Blacklist::SetBlacklistStateFetcherForTest(
     BlacklistStateFetcher* fetcher) {
-  state_fetcher_.reset(fetcher);
 }
 
 BlacklistStateFetcher* Blacklist::ResetBlacklistStateFetcherForTest() {
-  return state_fetcher_.release();
+  return NULL;
 }
 
 void Blacklist::AddObserver(Observer* observer) {
--- a/chrome/browser/profiles/profile_impl.cc
+++ b/chrome/browser/profiles/profile_impl.cc
@@ -453,13 +453,6 @@ ProfileImpl::ProfileImpl(
       path_, sequenced_task_runner, create_mode == CREATE_MODE_SYNCHRONOUS);
 #endif
 
-  scoped_refptr<SafeBrowsingService> safe_browsing_service(
-      g_browser_process->safe_browsing_service());
-  if (safe_browsing_service.get()) {
-    pref_validation_delegate_ =
-        safe_browsing_service->CreatePreferenceValidationDelegate(this).Pass();
-  }
-
   {
     prefs_ = chrome_prefs::CreateProfilePrefs(
         path_,
--- a/chrome/browser/ui/webui/interstitials/interstitial_ui.cc
+++ b/chrome/browser/ui/webui/interstitials/interstitial_ui.cc
@@ -46,99 +46,6 @@ class InterstitialHTMLSource : public content::URLDataSource {
   DISALLOW_COPY_AND_ASSIGN(InterstitialHTMLSource);
 };
 
-SSLBlockingPage* CreateSSLBlockingPage(content::WebContents* web_contents) {
-  // Random parameters for SSL blocking page.
-  int cert_error = net::ERR_CERT_CONTAINS_ERRORS;
-  GURL request_url("https://example.com");
-  bool overridable = false;
-  bool strict_enforcement = false;
-  base::Time time_triggered_ = base::Time::NowFromSystemTime();
-  std::string url_param;
-  if (net::GetValueForKeyInQuery(web_contents->GetURL(),
-                                 "url",
-                                 &url_param)) {
-    if (GURL(url_param).is_valid())
-      request_url = GURL(url_param);
-  }
-  std::string overridable_param;
-  if (net::GetValueForKeyInQuery(web_contents->GetURL(),
-                                 "overridable",
-                                 &overridable_param)) {
-    overridable = overridable_param == "1";
-  }
-  std::string strict_enforcement_param;
-  if (net::GetValueForKeyInQuery(web_contents->GetURL(),
-                                 "strict_enforcement",
-                                 &strict_enforcement_param)) {
-    strict_enforcement = strict_enforcement_param == "1";
-  }
-  std::string clock_manipulation_param;
-  if (net::GetValueForKeyInQuery(web_contents->GetURL(), "clock_manipulation",
-                                 &clock_manipulation_param) == 1) {
-    cert_error = net::ERR_CERT_DATE_INVALID;
-    int time_offset;
-    if (base::StringToInt(clock_manipulation_param, &time_offset)) {
-      time_triggered_ += base::TimeDelta::FromDays(365 * time_offset);
-    } else {
-      time_triggered_ += base::TimeDelta::FromDays(365 * 2);
-    }
-  }
-  net::SSLInfo ssl_info;
-  ssl_info.cert = new net::X509Certificate(
-      request_url.host(), "CA", base::Time::Max(), base::Time::Max());
-  // This delegate doesn't create an interstitial.
-  int options_mask = 0;
-  if (overridable)
-    options_mask |= SSLBlockingPage::OVERRIDABLE;
-  if (strict_enforcement)
-    options_mask |= SSLBlockingPage::STRICT_ENFORCEMENT;
-  return new SSLBlockingPage(web_contents, cert_error, ssl_info, request_url,
-                             options_mask, time_triggered_, nullptr,
-                             base::Callback<void(bool)>());
-}
-
-SafeBrowsingBlockingPage* CreateSafeBrowsingBlockingPage(
-    content::WebContents* web_contents) {
-  SBThreatType threat_type = SB_THREAT_TYPE_URL_MALWARE;
-  GURL request_url("http://example.com");
-  std::string url_param;
-  if (net::GetValueForKeyInQuery(web_contents->GetURL(),
-                                 "url",
-                                 &url_param)) {
-    if (GURL(url_param).is_valid())
-      request_url = GURL(url_param);
-  }
-  std::string type_param;
-  if (net::GetValueForKeyInQuery(web_contents->GetURL(),
-                                 "type",
-                                 &type_param)) {
-    if (type_param == "malware") {
-      threat_type =  SB_THREAT_TYPE_URL_MALWARE;
-    } else if (type_param == "phishing") {
-      threat_type = SB_THREAT_TYPE_URL_PHISHING;
-    } else if (type_param == "clientside_malware") {
-      threat_type = SB_THREAT_TYPE_CLIENT_SIDE_MALWARE_URL;
-    } else if (type_param == "clientside_phishing") {
-      threat_type = SB_THREAT_TYPE_CLIENT_SIDE_PHISHING_URL;
-      // Interstitials for client side phishing urls load after the page loads
-      // (see SafeBrowsingBlockingPage::IsMainPageLoadBlocked), so there should
-      // either be a new navigation entry, or there shouldn't be any pending
-      // entries. Clear any pending navigation entries.
-      content::NavigationController* controller =
-          &web_contents->GetController();
-      controller->DiscardNonCommittedEntries();
-    }
-  }
-  SafeBrowsingBlockingPage::UnsafeResource resource;
-  resource.url = request_url;
-  resource.threat_type =  threat_type;
-  // Create a blocking page without showing the interstitial.
-  return SafeBrowsingBlockingPage::CreateBlockingPage(
-      g_browser_process->safe_browsing_service()->ui_manager().get(),
-      web_contents,
-      resource);
-}
-
 } //  namespace
 
 InterstitialUI::InterstitialUI(content::WebUI* web_ui)
@@ -182,16 +89,9 @@ void InterstitialHTMLSource::StartDataRequest(
     int render_frame_id,
     const content::URLDataSource::GotDataCallback& callback) {
   scoped_ptr<content::InterstitialPageDelegate> interstitial_delegate;
-  if (base::StartsWith(path, "ssl", base::CompareCase::SENSITIVE)) {
-    interstitial_delegate.reset(CreateSSLBlockingPage(web_contents_));
-  } else if (base::StartsWith(path, "safebrowsing",
-                              base::CompareCase::SENSITIVE)) {
-    interstitial_delegate.reset(CreateSafeBrowsingBlockingPage(web_contents_));
-  }
 
   std::string html;
-  if (interstitial_delegate.get()) {
-    html = interstitial_delegate.get()->GetHTMLContents();
+  if (false) {
   } else {
     html = ResourceBundle::GetSharedInstance()
                           .GetRawDataResource(IDR_SECURITY_INTERSTITIAL_UI_HTML)
--- a/chrome/browser/renderer_host/chrome_resource_dispatcher_host_delegate.cc
+++ b/chrome/browser/renderer_host/chrome_resource_dispatcher_host_delegate.cc
@@ -351,9 +351,6 @@ void ChromeResourceDispatcherHostDelegate::RequestBeginning(
     content::AppCacheService* appcache_service,
     ResourceType resource_type,
     ScopedVector<content::ResourceThrottle>* throttles) {
-  if (safe_browsing_.get())
-    safe_browsing_->OnResourceRequest(request);
-
   const ResourceRequestInfo* info = ResourceRequestInfo::ForRequest(request);
   bool is_prerendering =
       info->GetVisibilityState() == blink::WebPageVisibilityStatePrerender;
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -549,10 +549,6 @@ class SafeBrowsingSSLCertReporter : public SSLCertReporter {
   // SSLCertReporter implementation
   void ReportInvalidCertificateChain(
       const std::string& serialized_report) override {
-    if (safe_browsing_ui_manager_) {
-      safe_browsing_ui_manager_->ReportInvalidCertificateChain(
-          serialized_report, base::Bind(&base::DoNothing));
-    }
   }
 
  private:
@@ -1830,12 +1826,8 @@ void ChromeContentBrowserClient::AllowCertificateError(
   if (expired_previous_decision)
     options_mask |= SSLBlockingPage::EXPIRED_BUT_PREVIOUSLY_ALLOWED;
 
-  SafeBrowsingService* safe_browsing_service =
-      g_browser_process->safe_browsing_service();
   scoped_ptr<SafeBrowsingSSLCertReporter> cert_reporter(
-      new SafeBrowsingSSLCertReporter(safe_browsing_service
-                                          ? safe_browsing_service->ui_manager()
-                                          : nullptr));
+      new SafeBrowsingSSLCertReporter(nullptr));
   SSLErrorHandler::HandleSSLError(tab, cert_error, ssl_info, request_url,
                                   options_mask, cert_reporter.Pass(), callback);
 }

